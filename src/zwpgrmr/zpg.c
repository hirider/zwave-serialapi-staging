/* Â© 2014 Silicon Laboratories Inc.
 */

#include "zpg.h"
#include <string.h>
#include "crc32.h"
#include <unistd.h>
/* Include the USB loader as a binary blob.
   Generated by Makefile.usb_loader */
#include "usb_loader_part1.h"
#include "usb_loader_part2.h"

#define USB_WRITE_BURST 3
#define USB_READ_BURST 1   /* Setting to 3 may speed up flash readback. But needs testing. */

#define SUCCESS 0 /* Success return code from most zpg_ and zpgp_ */
/**
 * Perform a build read of SRAM or FLASH
 *
 * return -1 on error
 */
static int
bulk_read(zw_pgmr_t* p, u8_t*buf, u16_t len)
{
  /* Number of commands to burst read */
  int burst = p->usb ? USB_READ_BURST : 1;;
  u8_t t[3 * burst];

  /*Number of triplets to read */
  int left = len/3 +1;

  /*number of commands to use in this cycle.*/
  int n;
  int s =0;

  while(left > 0) {
    n = left < burst ? left : burst;
    if (zpgp_continue_read(p, t, n))
    {
      return -1;
    }
    left -= n;

    memcpy(&buf[s],t, left ? 3*n : len-s);
    s+= 3*n;
  }

  return len;
}

/**
 * Read a single sector from flash.
 */
int
zpg_read_flash_sector(zw_pgmr_t* p, u8_t sector, u8_t*buf)
{
  buf[0] = zpgp_read_flash(p, sector);
  return bulk_read(p, &buf[1], p->blk_sz - 1);
}

/**
 * Read a region of SRAM
 */
int
zpg_bulk_read_SRAM(zw_pgmr_t* p, u16_t addr, u16_t len, u8_t* buf)
{
  buf[0] = zpgp_read_SRAM(p, addr);
  return bulk_read(p, &buf[1], len - 1);
}

/**
 * Write SRAM
 */
int
zpg_bulk_write_SRAM(zw_pgmr_t* p, u16_t addr, u16_t len, const u8_t*buf)
{
  int i, c;

  int burst = p->usb ? USB_WRITE_BURST : 1;
  u8_t t[burst * 3];

  if (zpgp_write_SRAM(p, addr, buf[0]))
  {
    return -1;
  }

  for (i = 1; i < len; i += 3 * burst)
  {
    /* Burst reduce bursts to something smaller*/
    while( (i+3*burst) > len) burst--;

    memcpy(t, &buf[i], 3 * burst);
    if (zpgp_continue_write(p, t, burst))
    {
      return -1;
    }
  }

  c = i - len;

  if (c)
  {
    for (i = len - c; i < len; i++)
    {
      if (zpgp_write_SRAM(p, addr + i, buf[i]))
      {
        return -1;
      }
    }
  }
  return 0;
}

/**
 * The "Read Signature Byte" command reads a signature byte from the chip
 * jedec_id = 7f7f7f71f
 * chip_type = 0x4
 * rev = (x01)
 */
int
read_signature_bytes(zw_pgmr_t* p, struct signature* sig)
{
  u8_t *q = (u8_t*) sig;
  int i, v;
  memset(sig,0,sizeof(struct signature));
  for (i = 0; i < 7; i++)
  {
    int v = zpgp_read_signature_byte(p, i);
    if(v<0) {
      return 0 ;
    }
    *q++ = (v) & 0xFF;
  }

  p->con("Chip signature:\n");
  p->con("  JDEC ID %.2x%.2x%.2x%.2x%.2x\n", sig->jdec_id[0], sig->jdec_id[1],
      sig->jdec_id[2], sig->jdec_id[3], sig->jdec_id[4]);
  p->con("  Type %i revision %i\n", sig->chip_type, sig->chip_revision);

  v = (sig->chip_type == 4 && sig->jdec_id[0] == 0x7F && sig->jdec_id[1] == 0x7F
      && sig->jdec_id[2] == 0x7F && sig->jdec_id[3] == 0x7F
      && sig->jdec_id[4] == 0x1F);
  if (!v)
  {
    p->err("Bad chip signature\n");
  }
  else
  {
    p->blk_sz = 2048; //ZW05xx
    p->blk_num = 64;
  }

  return v;
}

/**
 * Try to enable and sync programming interface.
 *
 * Return true on success
 *
 * Figure 25
 */
int
enable_and_sync_interface(zw_pgmr_t* p)
{
  u8_t cmd[8];
  u8_t rxed, i;

  for (i = 0; i < 3; i++)
  {
    cmd[0] = 0xAC;
    cmd[1] = 0x53;
    cmd[2] = 0xAA;
    cmd[3] = 0x55;

    rxed = p->xfer(cmd, 4, 4);
    if ((rxed >= 2) && cmd[2] == 0xAA && cmd[3] == 0x55)
    {
      return 1; //Sync!
    }
    else if (rxed == 0)
    {
      p->err("No data received during sync\n");
      break; //No data
    }
    else
    {
      cmd[0] = 0; //Send dummy
      p->xfer(cmd, 1, 1);
    }
  }
  p->err("Unable to sync programming interface\n");
  return 0;
}

/**
 * Figure 27, SPI/UART Program Flash Code Space
 *
 * Program a code sector.
 * @param sector the flash sector to be programmed
 * @param start the start offset into data/flash area where we need to program
 * @param pointer to a 2k byte array of data
 * @param end the last address to program.
 *
 */
int
program_flash_code_space(zw_pgmr_t* p, int sector, int start, const u8_t* data, int end)
{
  int len;
  int burst = p->usb ? USB_WRITE_BURST : 1;
  int ntriplets;
  /*Skip leading 0xFF*/
  while (data[start] == 0xFF && start < end)
    start++;

  /*Skip trailing 0xFF */
  while (data[end - 1] == 0xFF && end > start)
    end--;

  /*Nothing to program*/
  if (end <= start)
  {
    p->con("skipping section\n");
    return 0;
  }

  len = end - start;

  p->con("Programming sector %i bytes %i\r\n", sector, len);

  while(1) {
    /*Write the first byte*/
    if(zpgp_write_SRAM(p, start, data[start])) {
      return -1;
    }
    start++;
    ntriplets = (end-start) / 3; //The number of triplets to program

    /*The last triplet must not end with 0xFF, if so single-byte-write the first
     * byte and go another round */
    if(ntriplets>0 && data[start+ntriplets*3-1] == 0xFF) {
      if (zpgp_write_flash_sector(p, sector))
      {
        return -1;
      }
    } else {
      break;
    }
  };


  /* Write triplets */
  while(ntriplets) {
    if( burst > ntriplets) {
      burst = ntriplets;
    }
    if(zpgp_continue_write(p, &data[start], burst)) {
      return -1;
    }
    ntriplets -= burst;
    start+= burst*3;
  }
  /* Write the data just stored in SRAM */
  if (zpgp_write_flash_sector(p, sector))
  {
    return -1;
  }

  /*Flash the last bytes with single commands */
  for ( ; start < end; start++)
  {
    if(data[start] !=0xFF) {
      zpgp_write_SRAM(p, start, data[start]);
      if (zpgp_write_flash_sector(p, sector))
      {
        return -1;
      }
    }
  }
  return 0;
}

/**
 * Initalize the programmer
 */
int
zpg_init(zw_pgmr_t* p)
{
  p->con("zpg_init\n");
  int i;

  for (i = 0; i < 3; i++)
  {

    if (!enable_and_sync_interface(p))
    {
      return -1;
    }

    if (read_signature_bytes(p, &p->sig))
    {
      break;
    }
    p->xfer(0, 0,1);
  }

  return i == 3 ? -1 : 0;
}

/* Program and boot the USB loader
 * The chip MUST not be in auto programming mode
 * in this state.
 */
static int program_and_boot_usb_loader(zw_pgmr_t* p) {
  int i=0;
  u8_t sector[0x800];

  for(i=0; i < 10; i++) {
    /* Write first part as fast as possible */
    program_flash_code_space(p,0,0,usb_loader_part1,0x500);
    program_flash_code_space(p,0,0x508,usb_loader_part1,0x800);

    zpg_read_flash_sector(p,0,sector);
    if(memcmp(sector,usb_loader_part1,0x800) ==0) {
      break;
    }
    p->err("verify of usb_loader1 failed\n");
    zpgp_erase_sector(p,0);
  }
  if(i==10) {
    p->err("Fatal error. Failed to load the usb loader. I hope this was not a USB stick :-(");
    zpgp_erase_chip(p);
    return -1;
  }
  /* Program the rest of sector 0 */
  program_flash_code_space(p,0,0x0,usb_loader_part2,0x800);

  /* Clear lock bit 1 to leave APM mode and use the usb loader we just flashed */
  zpgp_set_lock_bits(p, RBAP, ~RBAP_AUTOPROG1);

  zpgp_reset_chip(p);
  return 1;
}
/**
 * Program the CHIP
 * \param data An memory buffer that containt the binray data. It must be atleast the same size at the flash
 * \param size Size of the FLASH
 */
int
zpg_program_chip(zw_pgmr_t* p, u8_t* data, int size)
{
  u8_t nvr[0xFF];
  u8_t lockbits[9];
  int i, r;

  if (size < p->blk_num * p->blk_sz)
  {
    p->err("Data buffer not big enough\n");
    return -1;
  }

  /* Read NVR and store data */
  for (i = 0x9; i < 0xFF; i++)
  {
    if ((r = zpgp_read_nvr(p, i)) < 0)
    {
      return -1;
    }
    nvr[i] = (u8_t) r;
  }

  /*TODO NVR CRC check*/
  /* Read LockBits and store data */
  for (i = 0; i < 0x9; i++)
  {
    if ((r = zpgp_read_lock_bits(p, i)) < 0)
    {
      return -1;
    }
    lockbits[i] = (u8_t) r;
    p->con("%x: lockbits 0x%x\n",i,lockbits[i]);
  }

  /*
   * Erase code space, NVR and Lock bits
   */
  if (zpgp_erase_chip(p) < -1)
  {
    return -1;
  }

  /* Program NVR */
  for (i = 0x9; i < 0xFF; i++)
  {
    if ((r = zpgp_set_nvr(p, i, nvr[i])) < 0)
    {
      return -1;
    }
    if ((r = zpgp_read_nvr(p, i)) != nvr[i])
    {
      p->err("%s nvr verify fail, %x != %x at idx %x \n",__FUNCTION__, r, nvr[i], i);
      return -2;
    }
  }

  if (p->apm && ! (p->usb == 2))
  {
    /*Clear AutoProg0 Lockbit*/
    zpgp_set_lock_bits(p, RBAP, ~RBAP_AUTOPROG0);
  }

  /* start the usb loader, if this is the "native" usb programmer interface  */
  if(p->usb == 1) {
    p->con("Programming the USB loader\n");
    program_and_boot_usb_loader(p);

    /*Re-init the programming interface*/
    p->close();

    usleep(2*1000*1000);
    
    if(!p->open(p,"USB")) {
      p->err("Unable to re-connect to usb loader #1\n");
      return -1;
    }
    if(p->usb!=2 ) {
      p->err("Unable to re-connect to usb loader #2\n");
      return -1;
    }
  }

  if(p->usb) {
    /*In the usb targets we cannot use data erea*/
    memset(&data[0x500],0xff,8);
  }
  /*
   * Calculate Flash Code Space CRC32 value
   */
  insertCRC(data, size);

  /*
   *  Program Flash Code Space, skip sector 0 if this is usb
   *  Retry sectors that fail.
   */
  for (i = p->usb ? 1 : 0 ; i < size / p->blk_sz; i++)
  {
    int retry_count = 3;
    while(retry_count--) {
      int retval = program_flash_code_space(p, i,0, &data[ 0x800 * i ], 0x800);
      if (SUCCESS == retval) {
        break; /* proceed to next sector */
      } else {
        p->con("Retrying sector %u\n", i);
        zpgp_erase_sector(p, i);
      }
    }
  }

  /*In usb mode we need to go into autoprogramming mode now */
  if(p->usb == 2) {
    u8_t ZW_FLASH_auto_prog_set[] = {0x01, 0x03, 0x00, 0x27, 0xDB};

    p->con("Exiting the USB loader\n");

    /* Clear AutoProg0 Lockbit */
    zpgp_set_lock_bits(p, RBAP, ~RBAP_AUTOPROG0);
    p->xfer(ZW_FLASH_auto_prog_set,sizeof(ZW_FLASH_auto_prog_set),1);
    zpgp_reset_chip(p);
    p->close();

    /* Wait for chip to reappear in APM mode. Watchdog restart causes one second delay. */
    usleep(2*1000*1000);

    p->open(p,"USB");

    if(p->usb != 1) {
      p->err("device did no start in native programming mode\n");
      return -1;
    }
    enable_and_sync_interface(p);

    /*Program the real sector 0*/
    zpgp_erase_sector(p,0);

    /*Program sector 0, leaving out 0x500 - 0x508 */
    program_flash_code_space(p,0,0x0, data,0x500);
    program_flash_code_space(p,0,0x508,data,0x800);
  }


  /**
   * Check CRC32 Checksum
   */
  if (zpgp_run_CRC_check(p) < 0)
  {
    return -1;
  }
  /*CRC Check Done?*/
  while ((r = zpgp_check_state(p)) & CRC_BUSY)
  {
    if (r < 0)
    {
      return -1;
    }
  }
  /* CRC Check Passed? */
  if (r & CRC_FAILED)
  {
    p->con("CRC32 failed!\n");
    return -1;
  } else {
    p->con("CRC32 PASSED\n");
  }

  //if (p->apm)
  {
    /*Clear AutoProg0-1 Lockbit*/
    lockbits[RBAP] &= ~(RBAP_AUTOPROG1 | RBAP_AUTOPROG0);
  }

  /*  Program Lock Bits */
  for (i = 0; i < 0x9; i++)
  {
    if ((r = zpgp_set_lock_bits(p, i, lockbits[i])) < 0)
    {
      return -1;
    }
  }

  zpgp_reset_chip(p);
  return 0;
}

/**
 * Programmer read chip
 * \param data An memory buffer that containt the binray data. It must be atleast the same size at the flash
 * \param size Size of the FLASH
 * \return the number of bytes actually read
 */
int
zpg_read_chip(zw_pgmr_t* p, u8_t* data, int offset, int length)
{
  int s;
  int n = 0;
  for (s = offset / p->blk_sz; s < (length + offset) / p->blk_sz ; s++)
  {
    p->con("Reading sector %i bytes %i \r\n", s, p->blk_sz);
    zpg_read_flash_sector(p, s, data + p->blk_sz * n);
    n++;
  }
  return n * p->blk_sz;
}

