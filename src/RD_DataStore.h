/* Â© 2019 Silicon Laboratories Inc.  */

#ifndef RD_DATASTORE_H_
#define RD_DATASTORE_H_
#include <stdlib.h>
#include <stdbool.h>
#include "RD_internal.h"

#ifdef __cplusplus
extern "C"
{
#endif

/**
 * \ingroup ZIP_Resource
 * \defgroup rd_data_store Resource Directory Persistent Data Store
 *
 * This component handles persistent storage and import of the data in
 * the \ref ZIP_Resource, so that the data can survive stopping and
 * restarting the Z/IP Gateway process.
 *
 * @{
 */

void rd_data_store_version_get(uint8_t *major, uint8_t *minor);

/**
 * Read in the persistent data storage header.
 *
 * If the stored data do not match the information on the serial API,
 * or if it is not generated by a Z/IP Gateway, invalidate the storage
 * area, so that it will be re-initialized.
 *
 * If the stored data is recognized as one of the (supported) older
 * formats a conversion to the current format is automatically performed.
 *
 * @return false if the datastore cannot be converted (because of
 *               unknown or unsupported format).
 * @return true  otherwise.
 */
bool data_store_init(void);

/**
 * @brief Shut down the data store clean.
 *
 */
void data_store_exit(void);

/**
 * Read node entry from persistent storage. Return a newly allocated
 * rd_node_database_entry_t on success. The returned entry must be freed with
 * smfree
 */
rd_node_database_entry_t* rd_data_store_read(nodeid_t nodeID);

/**
 * Write a rd_node_database_entry_t and all its endpoints to storage.
 * This is called when a new node is added. Note that this call would clean up
 * the old entry together with its endpoints and create a new one.
 */
void rd_data_store_nvm_write(rd_node_database_entry_t *n);

/**
 * Update all node and endpoint info in persistent storage.
 *
 * Call when a the status of a node or its endpoints has changed. This
 * function assumes the number of endpoints to be matched with what entry
 * n has.
 */
void rd_data_store_update(rd_node_database_entry_t *n);

/**
 * Free up all storage associated with a node and its endpoints from \ref node_db.
 *
 * @param n Pointer to the node in \ref node_db.
 */
void rd_data_store_mem_free(rd_node_database_entry_t *n);

/**
 * Free the endpoint data, the dynamic data, and the node pointer for
 * a node in the \ref rd_data_store.
 */
void rd_data_store_nvm_free(rd_node_database_entry_t *n);


/**
 * Free endpoint from memory.
 */
void rd_store_mem_free_ep(rd_ep_database_entry_t* ep);


/**
 * Allocate and deallocate memory from the rd_data_mem pool.
 */
void* rd_data_mem_alloc(uint8_t size);
void rd_data_mem_free(void* p);

/**
 * Corrupt the magic field of EEPROM to make sure EEPROM will be reformatted.
 */
void rd_data_store_invalidate();

/**
 * Get ZGW home ID from RD datastore.
 */
uint32_t rd_zgw_homeid_get();

/**
 * Get ZGW node ID RD datastore.
 */
nodeid_t rd_zgw_nodeid_get();

#ifdef __cplusplus
}
#endif

#endif /* RD_DATASTORE_H_ */
