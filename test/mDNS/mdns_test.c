//#include "mdns_test.h"
#include "mDNSService.h"
#include "stdio.h"
#include <unistd.h>
#include <zwdb.h>
#include <stdlib.h> //for get_gen_type_string()
#include <string.h>
#include <unity.h>

//Test defines
#define TEST_HOMEID_1 0xdeec4e80
#define TEST_HOMEID_2 0xbf46ed30

unsigned char output_buf[1024];
int output_len = 0;
int probe_len;
rd_ep_database_entry_t ep;
extern dns_message_t test_m; 
/* Symbols needed by MDNS */
/*---------------------------------------------------------------------*/

/* Simulates the storage of the homeID in Network byte order */
uint32_t homeID = UIP_HTONL(TEST_HOMEID_1);
int dont_set_cache_flush_bit = 0;
u8_t ipv46nat_ipv4addr_of_node(uip_ipv4addr_t* ip,nodeid_t node)
{
    ip->u8[0] = 172;
    ip->u8[1] = 16;
    ip->u8[2] = 1;
    ip->u8[3] = 200;
    return 1;
}

rd_ep_database_entry_t*
rd_group_ep_iterator_next(rd_group_entry_t* ge, rd_ep_database_entry_t* ep)
{         
  return 0;
}

int 
rd_ep_class_support(rd_ep_database_entry_t* ep, uint16_t cls)
{
  return 0;
}

rd_ep_database_entry_t*
rd_ep_iterator_group_begin(rd_group_entry_t* ge)
{   
  return 0;
}

rd_group_entry_t*
rd_lookup_group_by_name(const char* name)
{
  return 0;
}

void
ipOfNode(uip_ip6addr_t* dst, nodeid_t nodeID)
{
    return;
}

u8_t
rd_get_node_name(rd_node_database_entry_t* n, char* buf, u8_t size)
{
  if (n->nodeNameLen)
  {
    if (size > n->nodeNameLen)
    {
      size = n->nodeNameLen;
    }
    memcpy(buf, n->nodename, size);
    return size;
  }
  else
  {
    return snprintf(buf, size, "zw%08X%04X", UIP_HTONL(homeID), n->nodeid);
  }
}
rd_node_database_entry_t*
rd_lookup_by_node_name(const char* name)
{
//    return ep.node;
    return 0;
}

rd_ep_database_entry_t*
rd_ep_next(nodeid_t node, rd_ep_database_entry_t* ep)
{
    return NULL;
}
rd_ep_database_entry_t*
rd_ep_first(nodeid_t node)
{
    return &ep;
}

u8_t rd_get_ep_name(rd_ep_database_entry_t* ep, char* buf, u8_t size)
{
  if (ep->endpoint_name && ep->endpoint_name_len)
  {
    if (size > ep->endpoint_name_len)
    {
      size = ep->endpoint_name_len;
    }
    memcpy(buf, ep->endpoint_name, size);
    return size;
  }
  else
  {

    if (ep->endpoint_info && (ep->endpoint_info_len > 2))
    {
      const char* type_str = get_gen_type_string(ep->endpoint_info[0]);
      return snprintf(buf, size, "%s [%04x%04x%02x]",
          type_str, UIP_HTONL(homeID), ep->node->nodeid,
          ep->endpoint_id);
    }
    else
    {
      return snprintf(buf, size, "(unknown) [%04x%04x%02x]", UIP_HTONL(homeID),
          ep->node->nodeid, ep->endpoint_id);
    }
  }
}
void ctimer_set(struct ctimer *c, clock_time_t t,
                void (*f)(void *), void *ptr)
{
    usleep(t);
    f(ptr);
    return;
}

void ctimer_stop(struct ctimer *c)
{
}

uint8_t MyNodeID = 0;
void *uip_appdata;

int test_uip_datalen()
{
    return probe_len;
}
#define KEY_CLASS_S0                  0x80
#define KEY_CLASS_S2_UNAUTHENTICATED  0x01
#define KEY_CLASS_S2_AUTHENTICATED    0x02
#define KEY_CLASS_S2_ACCESS           0x04
#define KEY_CLASS_ALL                 0xFF

uint8_t GetCacheEntryFlag(nodeid_t nodeid)
{
    return 0;
}
uint8_t sec2_gw_node_flags2keystore_flags(uint8_t gw_flags) {
  return KEY_CLASS_S2_UNAUTHENTICATED|KEY_CLASS_S2_AUTHENTICATED;
}
/**
 *   +---------------------+
 |        Header       |
 +---------------------+
 |       Question      | the question for the name server
 +---------------------+
 |        Answer       | RRs answering the question
 +---------------------+
 |      Authority      | RRs pointing toward an authority
 +---------------------+
 |      Additional     | RRs holding additional information
 +---------------------+
 */
void
mdns_hexdump(uint8_t* buf, int size)
{
  int i;
  printf("len: %d\n", size);
  for (i = 0; i < size; i++)
  {
    printf("%2.2x ", buf[i]);

    if ((i & 0xF) == 0xF)
    {
      printf("\n");
    }
  }
  printf("\n");
}
void uip_debug_ipaddr_print(const uip_ipaddr_t *addr)
{
    return;
}
/*---------------------------------------------------------------------*/

static void
rd_endpoint_name_probe_done(int bStatus, void* ctx)
{
    printf("callback called!\n");
}

void create_ep(rd_ep_database_entry_t *ep)
{
    ep->node = malloc(sizeof(rd_node_database_entry_t));
    memset(ep->node, 0,sizeof(rd_node_database_entry_t));
    ep->node->wakeUp_interval = 4200;
    ep->node->lastAwake = 0;
    ep->node->lastUpdate = 0;
    memset(&ep->node->ipv6_address,0, sizeof(uip_ip6addr_t));
    ep->node->nodeid = 1;
    ep->node->security_flags = 1;
    ep->node->mode = MODE_ALWAYSLISTENING;
    ep->node->state = STATUS_PROBE_NODE_INFO;
    ep->node->manufacturerID = 0x3278; 
    ep->node->productType = 0x1BF0;
    ep->node->productID = 0xC83E;
    ep->node->nodeType = 2;
    ep->node->refCnt= 0;
    ep->node->nEndpoints = 0;
    ep->node->nAggEndpoints = 0;
    ep->node->endpoints_list = 0; /*FIXME?*/
    ep->node->endpoints = 0;/*FIXME?*/
    ep->node->nodeNameLen = 0;
    ep->node->nodename = 0;

    ep->list = 0;
    ep->endpoint_location = 0;
    ep->endpoint_name = 0;
    ep->endpoint_info = malloc(30);
    memset(ep->endpoint_info, 0,30);
    ep->endpoint_info[0] = 2;
    ep->endpoint_agg = 0;
    ep->endpoint_info_len = 30;
    ep->endpoint_name_len = 0;
    ep->endpoint_loc_len = 0 ;
    ep->endpoint_aggr_len = 0;
    ep->endpoint_id = 0;
    ep->state = EP_STATE_MDNS_PROBE_IN_PROGRESS;
    ep->installer_iconID = 0x9037;
    ep->user_iconID = 0xDBCA;
}

const unsigned char probe_1[] = {
 0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x03 ,0x00 ,0x00 ,0x22 ,0x53 ,0x74 ,0x61,
 0x74 ,0x69 ,0x63 ,0x20 ,0x43 ,0x6f ,0x6e ,0x74 ,0x72 ,0x6f ,0x6c ,0x6c ,0x65 ,0x72 ,0x20 ,0x5b,
 0x64 ,0x65 ,0x65 ,0x63 ,0x34 ,0x65 ,0x38 ,0x30 ,0x30 ,0x30 ,0x30 ,0x31 ,0x30 ,0x30 ,0x5d ,0x07,
 0x5f ,0x7a ,0x2d ,0x77 ,0x61 ,0x76 ,0x65 ,0x04 ,0x5f ,0x75 ,0x64 ,0x70 ,0x05 ,0x6c ,0x6f ,0x63,
 0x61 ,0x6c ,0x00 ,0x00 ,0xff ,0x00 ,0x01 ,0xc0 ,0x2f ,0x00 ,0x0c ,0x00 ,0x01 ,0x00 ,0x00 ,0x00,
 0x78 ,0x00 ,0x25 ,0x22 ,0x53 ,0x74 ,0x61 ,0x74 ,0x69 ,0x63 ,0x20 ,0x43 ,0x6f ,0x6e ,0x74 ,0x72,
 0x6f ,0x6c ,0x6c ,0x65 ,0x72 ,0x20 ,0x5b ,0x64 ,0x65 ,0x65 ,0x63 ,0x34 ,0x65 ,0x38 ,0x30 ,0x30,
 0x30 ,0x30 ,0x31 ,0x30 ,0x30 ,0x5d ,0xc0 ,0x2f ,0xc0 ,0x53 ,0x00 ,0x10 ,0x80 ,0x01 ,0x00 ,0x00,
 0x00 ,0x78 ,0x00 ,0x6a ,0x23 ,0x69 ,0x6e ,0x66 ,0x6f ,0x3d ,0x02 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
 0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
 0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x06 ,0x65 ,0x70 ,0x69 ,0x64 ,0x3d ,0x00 ,0x07,
 0x6d ,0x6f ,0x64 ,0x65 ,0x3d ,0x00 ,0x02 ,0x10 ,0x70 ,0x72 ,0x6f ,0x64 ,0x75 ,0x63 ,0x74 ,0x49,
 0x44 ,0x3d ,0x32 ,0x78 ,0x1b ,0xf0 ,0xc8 ,0x3e ,0x11 ,0x73 ,0x65 ,0x63 ,0x75 ,0x72 ,0x69 ,0x74,
 0x79 ,0x43 ,0x6c ,0x61 ,0x73 ,0x73 ,0x65 ,0x73 ,0x3d ,0x03 ,0x09 ,0x74 ,0x78 ,0x74 ,0x76 ,0x65,
 0x72 ,0x73 ,0x3d ,0x31 ,0x09 ,0x69 ,0x63 ,0x6f ,0x6e ,0x3d ,0x90 ,0x37 ,0xdb ,0xca ,0xc0 ,0x53,
 0x00 ,0x21 ,0x80 ,0x01 ,0x00 ,0x00 ,0x00 ,0x78 ,0x00 ,0x17 ,0x00 ,0x00 ,0x00 ,0x00 ,0xa1 ,0x0e,
 0x0e ,0x7a ,0x77 ,0x44 ,0x45 ,0x45 ,0x43 ,0x34 ,0x45 ,0x38 ,0x30 ,0x30 ,0x30 ,0x30 ,0x31 ,0xc0,
 0x3c
};

const unsigned char probe_2[364] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x0c, 0x7a, 0x77, 0x38, 0x30, 0x34, 0x45, 0x45, 0x43, 0x44, 0x45, 0x30, 0x31, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0xff, 0x00, 0x01, 0x01, 0x30, 0x01, 0x30, 0x01, 0x36, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01, 0x33, 0x01, 0x31, 0x01, 0x37, 0x01, 0x66, 0x01, 0x36, 0x01, 0x66, 0x01, 0x32, 0x01, 0x62, 0x01, 0x30, 0x01, 0x30, 0x01, 0x36, 0x01, 0x35, 0x01, 0x66, 0x01, 0x35, 0x01, 0x30, 0x01, 0x30, 0x01, 0x66, 0x01, 0x66, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01, 0x31, 0x01, 0x30, 0x03, 0x69, 0x70, 0x36, 0x04, 0x61, 0x72, 0x70, 0x61, 0x00, 0x00, 0xff, 0x00, 0x01, 0x03, 0x32, 0x30, 0x30, 0x01, 0x31, 0x02, 0x31, 0x36, 0x03, 0x31, 0x37, 0x32, 0x07, 0x69, 0x6e, 0x2d, 0x61, 0x64, 0x64, 0x72, 0xc0, 0x68, 0x00, 0xff, 0x00, 0x01, 0x0c, 0x7a, 0x77, 0x38, 0x30, 0x34, 0x45, 0x45, 0x43, 0x44, 0x45, 0x30, 0x31, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x10, 0xf7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xc0, 0x8d, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x04, 0xac, 0x10, 0x01, 0xc8, 0x01, 0x36, 0x01, 0x35, 0x01, 0x30, 0x01, 0x36, 0x01, 0x66, 0x01, 0x37, 0x01, 0x30, 0x01, 0x32, 0x01, 0x66, 0x01, 0x66, 0x01, 0x33, 0x01, 0x63, 0x01, 0x63, 0x01, 0x38, 0x01, 0x38, 0x01, 0x64, 0x01, 0x66, 0x01, 0x66, 0x01, 0x33, 0x01, 0x63, 0x01, 0x65, 0x01, 0x38, 0x01, 0x39, 0x01, 0x66, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01, 0x35, 0x01, 0x30, 0x03, 0x69, 0x70, 0x36, 0x04, 0x61, 0x72, 0x70, 0x61, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x14, 0x0c, 0x7a, 0x77, 0x38, 0x30, 0x34, 0x45, 0x45, 0x43, 0x44, 0x45, 0x30, 0x31, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x03, 0x32, 0x30, 0x30, 0x01, 0x31, 0x02, 0x31, 0x36, 0x03, 0x31, 0x37, 0x32, 0x07, 0x69, 0x6e, 0x2d, 0x61, 0x64, 0x64, 0x72, 0x04, 0x61, 0x72, 0x70, 0x61, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x14, 0x0c, 0x7a, 0x77, 0x38, 0x30, 0x34, 0x45, 0x45, 0x43, 0x44, 0x45, 0x30, 0x31, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00
};

/*Taken from line 678 in the capture.pcapng from email "Bonjour results" sent on  06/09/2016 */
const unsigned char question[] = {
0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x22 ,0x53 ,0x74 ,0x61 ,0x54 ,0x49 ,0x63 ,0x20 ,0x43 ,0x6f ,0x6e ,0x74 ,0x52 ,0x6f ,0x6c ,0x6c ,0x65 ,0x72 ,0x20 ,0x5b ,0x62, 0x66, 0x34, 0x36, 0x65, 0x64, 0x33, 0x30 , 0x30, 0x30, 0x30, 0x31 ,0x30 ,0x30 ,0x5d ,/*0x2d ,0x31 ,*/ 0x07 ,0x5f ,0x7a ,0x2d ,0x77 ,0x41 ,0x76 ,0x65 ,0x04 ,0x5f ,0x55 ,0x64 ,0x70 ,0x05 ,0x4c ,0x6f ,0x63 ,0x61 ,0x4c ,0x00 ,0x00 ,0x21 ,0x00 ,0x01
};

const unsigned char answer[] = {
0x00 ,0x00 ,0x84 ,0x00 ,0x00 ,0x00 ,0x00 ,0x03 ,0x00 ,0x00 ,0x00 ,0x00 ,0x22 ,0x53 ,0x74 ,0x61
,0x74 ,0x69 ,0x63 ,0x20 ,0x43 ,0x6f ,0x6e ,0x74 ,0x72 ,0x6f ,0x6c ,0x6c ,0x65 ,0x72 ,0x20 ,0x5b
,0x62 ,0x66 ,0x34 ,0x36 ,0x65 ,0x64 ,0x33 ,0x30 ,0x30 ,0x30 ,0x30 ,0x31 ,0x30 ,0x30 ,0x5d ,0x07
,0x5f ,0x7a ,0x2d ,0x77 ,0x61 ,0x76 ,0x65 ,0x04 ,0x5f ,0x75 ,0x64 ,0x70 ,0x05 ,0x6c ,0x6f ,0x63
,0x61 ,0x6c ,0x00 ,0x00 ,0x21 ,0x80 ,0x01 ,0x00 ,0x00 ,0x00 ,0x78 ,0x00 ,0x17 ,0x00 ,0x00 ,0x00
,0x00 ,0xa1 ,0x0e ,0x0e ,0x7a ,0x77 ,0x42 ,0x46 ,0x34 ,0x36 ,0x45 ,0x44 ,0x33 ,0x30 ,0x30 ,0x30
,0x30 ,0x31 ,0xc0 ,0x3c ,0xc0 ,0x53 ,0x00 ,0x1c ,0x80 ,0x01 ,0x00 ,0x00 ,0x00 ,0x78 ,0x00 ,0x10
,0x30 ,0x30 ,0x31 ,0x05 ,0x6c ,0x6f ,0x63 ,0x61 ,0x6c ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
,0xc0 ,0x53 ,0x00 ,0x01 ,0x80 ,0x01 ,0x00 ,0x00 ,0x00 ,0x78 ,0x00 ,0x04 ,0xac ,0x10 ,0x01 ,0xc8
};

/* " Static Controller [ca7293010100]\a_z-wave\004_udp\005local" */
char domain_name[53] = {
0x20	,0x53	,0x74	,0x61	,0x74	,0x69	,0x63	,0x20
,0x43	,0x6f	,0x6e	,0x74	,0x72	,0x6f	,0x6c	,0x6c
,0x65	,0x72	,0x20	,0x5b	,0x63	,0x61	,0x37	,0x32
,0x39	,0x33	,0x30	,0x31	,0x30	,0x31	,0x30	,0x30
,0x5d	,0x07	,0x5f	,0x7a	,0x2d	,0x77	,0x61	,0x76
,0x65	,0x04	,0x5f	,0x75	,0x64	,0x70	,0x05	,0x6c
,0x6f	,0x63	,0x61	,0x6c   ,0x00};

/* " Static Controller [ca7293010100]\a_z-wave\004_udp\005local" */
char domain_name1[53] = {
0x20	,0x53	,0x74	,0x61	,0x74	,0x69	,0x63	,0x20
,0x43	,0x6f	,0x6e	,0x74	,0x72	,0x6f	,0x6c	,0x6c
,0x65	,0x72	,0x20	,0x5b	,0x63	,0x61	,0x37	,0x32
,0x39	,0x33	,0x30	,0x31	,0x30	,0x31	,0x30	,0x30
,0x5d	,0x07	,0x5f	,0x7a	,0x2d	,0x77	,0x61	,0x76
,0x65	,0x04	,0x5f	,0x75	,0x64	,0x70	,0x05	,0x6c
,0x6f	,0x63	,0x61	,0x6c   ,0x00};
/* " Static Controller [aa7293010100]\a_z-wave\004_udp\005local" */
char domain_name2[53] = {
0x20	,0x53	,0x74	,0x61	,0x74	,0x69	,0x63	,0x20
,0x43	,0x6f	,0x6e	,0x74	,0x72	,0x6f	,0x6c	,0x6c
,0x65	,0x72	,0x20	,0x5b	,0x61	,0x61	,0x37	,0x32
,0x39	,0x33	,0x30	,0x31	,0x30	,0x31	,0x30	,0x30
,0x5d	,0x07	,0x5f	,0x7a	,0x2d	,0x77	,0x61	,0x76
,0x65	,0x04	,0x5f	,0x75	,0x64	,0x70	,0x05	,0x6c
,0x6f	,0x63	,0x61	,0x6c   ,0x00};

/* " Static Controller [aa7293010100]\a_z-wave\004_udp\005local" */
char domain_name3[27] = {
0x02, 0x6d, 0x69, 0x02, 0x6d, 0x69
,0x07 ,0x5f	,0x7a   ,0x2d	,0x77	,0x61	,0x76
,0x65	,0x04	,0x5f	,0x75	,0x64	,0x70	,0x05	,0x6c
,0x6f	,0x63	,0x61	,0x6c   ,0x00};

char domain_name4[21] = {
0x0c, 0x7a,0x77,0x43,0x41,0x37,0x32,0x39,0x33,0x30,0x31,0x30,0x31, 0x07, 0x6c,0x6f,0x63,0x61,0x6c, 0x07
};
char domain_name5[21] = {
0x0c, 0x79,0x77,0x43,0x41,0x37,0x32,0x39,0x33,0x30,0x31,0x30,0x31, 0x07, 0x6c,0x6f,0x63,0x61,0x6c, 0x07
};
void test_mdns()
{
    int ret = 0;
    int i;
    
    create_ep(&ep);
    /* TODO: Fill ep*/
    mdns_endpoint_name_probe(&ep, rd_endpoint_name_probe_done, &ep);
    TEST_ASSERT_EQUAL_UINT8_ARRAY_MESSAGE(output_buf, probe_1, sizeof(probe_1), "ERROR: mdns_endpoint_name_probe failed");
    //mdns_node_name_probe(ep.node, test_rd_endpoint_name_probe_done, ep.node);
    //for ( i = 0; i< sizeof(probe_2); i++) {
    //    if((unsigned char)output_buf[i] != (unsigned char)probe_2[i]) {
    //    printf("------ %d output_buf[i]:%x probe_2[i]:%x\n", i, output_buf[i], probe_2[i]);
    //        printf("------ i:%d output_buf[i]:%d\n", i, output_buf[i]);
    //    }
    //}

    //TEST_ASSERT_EQUAL_UINT8_ARRAY_MESSAGE(output_buf, probe_2, sizeof(probe_2), "ERROR: mdns_node_name_probe failed");

    uip_appdata = malloc(sizeof(question));
    memcpy(uip_appdata, question, sizeof(question));
    probe_len = sizeof(question);
    homeID = UIP_HTONL(TEST_HOMEID_2); /* Simulate storage of the HomeID in network byte order */
    hook_tcpip_handler();
    TEST_ASSERT_EQUAL_UINT8_ARRAY_MESSAGE(output_buf, answer, sizeof(answer), "ERROR: Answer to incoming MDNS queestion failed");

     /* test adding(compression) domain names. All the steps below try adding different domain names and are verified if the compression is done
      * where possible, by checking the returned legth.
      *
      * See the comments above each domain_name* structures 
      * */
    init_dns_message(&test_m, test_reply, sizeof(test_reply), 0);
    TEST_ASSERT_TRUE_MESSAGE((add_domain_name_compressed(&test_m, domain_name) == sizeof(domain_name)), "add_domain_name_compressed passed\n")
    TEST_ASSERT_TRUE_MESSAGE((add_domain_name_compressed(&test_m, domain_name1) == 2), "add_domain_name_compressed2 passed\n")
    TEST_ASSERT_TRUE_MESSAGE((add_domain_name_compressed(&test_m, domain_name2) == 35), "add_domain_name_compressed3 passed\n")
    TEST_ASSERT_TRUE_MESSAGE((add_domain_name_compressed(&test_m, domain_name3) == 8), "add_domain_name_compressed4 passed\n")
    TEST_ASSERT_TRUE_MESSAGE((add_domain_name_compressed(&test_m, domain_name4) == 22), "add_domain_name_compressed5 passed\n")
    TEST_ASSERT_TRUE_MESSAGE((add_domain_name_compressed(&test_m, domain_name5) == 15), "add_domain_name_compressed5 passed\n")
}
