/* Â© 2020 Silicon Laboratories Inc. */

#include <stdint.h>
#include <stdbool.h>
#include <uip.h>
#include <string.h>
#include <lib/zgw_log.h>
#include "mock_dhcp.h"
#include "mock_tapdev.h"

zgw_log_id_define(mockDHCP);
zgw_log_id_default_set(mockDHCP);

typedef union uip_ip4addr_t {
  uint8_t  u8[4];			/* Initializer, must come first!!! */
  u16_t u16[2];
} uip_ip4addr_t;

typedef struct ip4_hdr {
  /* IPV4 header */
  uint8_t vhl, tos; u16_t len;
  u16_t ipid, ipoffset;
  uint8_t ttl, proto; u16_t ipchksum;
  uip_ip4addr_t srcipaddr, destipaddr;
}  __attribute__ ((packed)) ip4_hdr_t ; //20 bytes

#define DHCPC_SERVER_PORT  67
#define DHCPC_CLIENT_PORT  68

uip_ip4addr_t ipv4_undef_addr = {0,0,0,0};

#define uip_ipv4addr_cmp(addr1, addr2) ((addr1)->u16[0] == (addr2)->u16[0] && \
                                        (addr1)->u16[1] == (addr2)->u16[1])

bool ip_packet_is_dhcp(uint8_t *pkt) {
   // dst addr is broadcast and port is dhcp
   ip4_hdr_t *ipv4_hdr = (ip4_hdr_t*)(pkt+14);

   return (uip_ipv4addr_cmp(&ipv4_hdr->destipaddr, &uip_broadcast_addr)
           && uip_ipv4addr_cmp(&ipv4_hdr->srcipaddr, &ipv4_undef_addr));
}

/* dhcp offer for the gw address */
uint8_t dhcp_server_msg_hdr[] = {
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xe6, 0xae, 0xfa, 0xea, 0xd9, 0x1d, // server addr
   0x08, 0x00,// ipv4
   // ip
   0x45, 0xc0, 0x01, 0x48,// ipv4, hdl, tos, length 0x011f
   0xac, 0x7b, 0x00, 0x00, 
   0x40, 0x11, 0x8b, 0x23,// ttl, proto udp, checksum
   0x0a, 0x46, 0x37, 0x01, // src
   0xff, 0xff, 0xff, 0xff, // dst
   // udp
   0x00, 0x43, 0x00, 0x44, //dhcp ports
   0x01, 0x34, 0x7f, 0xa1,
};
size_t udp_hdr_len = 42;
uint8_t dhcp_offer1[] = {
   0x02, 0x01, 0x06, 0x00, 0x91, 0x86 , 0x81, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x0a, 0x46, 0x37, 0x83, 0x0a, 0x46 , 0x37, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x63, 0xc4, 0x93,
   0xc5, 0x76, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x63, 0x82, 0x53, 0x63, 0x35, 0x01, 0x02, 0x36, 0x04, 0x0a , 0x46, 0x37, 0x01, 0x33, 0x04, 0x00,
   0x00, 0x0e, 0x10, 0x3a, 0x04, 0x00, 0x00, 0x07, 0x08, 0x3b , 0x04, 0x00, 0x00, 0x0c, 0x4e, 0x01,
   0x04, 0xff, 0xff, 0xff, 0x00, 0x1c, 0x04, 0x0a, 0x46, 0x37 , 0xff, 0x03, 0x04, 0x0a, 0x46, 0x37,
   0x01, 0x06, 0x04, 0x0a, 0x46, 0x37, 0x01, 0xff, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
size_t dhcp_offer_len = 300;

void mock_dhcp_server(uint8_t *pkt) {
   uint8_t *tmp = uip_buf;
   if (uip_len > 0) {
      // already processing stg else, what do??
      zgw_log(1, "Double booking uip_buf will not work\n");
      return;
   }
   
   memcpy(tmp, &dhcp_server_msg_hdr, udp_hdr_len);
   tmp += udp_hdr_len;
   memcpy(tmp, &dhcp_offer1, dhcp_offer_len);
   uip_len = udp_hdr_len + dhcp_offer_len;
   zgw_log(3, "Sending DHCP offer from mock\n");
   tcpip_input();

   // pkt handled
   lan_pkt_len = 0;
   return;
}

